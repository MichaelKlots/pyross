

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Bayesian inference &mdash; PyRoss 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Control with NPIs" href="control.html" />
    <link rel="prev" title="Hybrid simulations" href="hybrid.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> PyRoss
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="deterministic.html">Deterministic simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="stochastic.html">Stochastic simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="hybrid.html">Hybrid simulations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Bayesian inference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sir-type">SIR_type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spp">Spp</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sir">SIR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#seir">SEIR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#seairq">SEAIRQ</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="control.html">Control with NPIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="contactMatrix.html">Contact matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="forecast.html">Forecasting</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utils</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyRoss</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Bayesian inference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/inference.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="bayesian-inference">
<h1>Bayesian inference<a class="headerlink" href="#bayesian-inference" title="Permalink to this headline">¶</a></h1>
<p>Inference for age structured compartment models using the diffusion approximation (via the van Kampen expansion).
See our <a class="reference external" href="https://arxiv.org/abs/2005.09625">preprint</a> for more details on the method.</p>
<p>There are two ways to do inference: manifold method (sec 3.3 in the report) and tangent space method (sec 3.4 in the report).
Currently, all of the methods listed below are implemented for manifold, and <cite>infer_parameters</cite>, ‘latent_infer_parameters’,
‘obtain_minus_log_p’, ‘minus_logp_red’ are implemented for tangent space.</p>
<p>In various degrees of <cite>less robust but fast</cite> to <cite>more robust but slow</cite>:</p>
<ul class="simple">
<li><p>tangent space method.</p></li>
<li><p>manifold method with few internal steps and fast integration method (<cite>det_method</cite> = <cite>RK2</cite>, <cite>lyapunov_method</cite> = <cite>euler</cite>).</p></li>
<li><p>manifold method with large number of internel steps and robust integration method (<cite>solve_ivp</cite> from scipy library).</p></li>
</ul>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Methods for full data</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>infer_parameters</p></td>
<td><p>Infers epidemiological parameters given all information.</p></td>
</tr>
<tr class="row-odd"><td><p>infer_control</p></td>
<td><p>Infers control parameters.</p></td>
</tr>
<tr class="row-even"><td><p>obtain_minus_log_p</p></td>
<td><p>Computes -log(p) of a fully observed trajectory.</p></td>
</tr>
<tr class="row-odd"><td><p>compute_hessian</p></td>
<td><p>Computes the Hessian of -log(p).</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Methods for partial data</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>latent_infer_parameters</p></td>
<td><p>Infers parameters and initial conditions.</p></td>
</tr>
<tr class="row-odd"><td><p>latent_infer_control</p></td>
<td><p>Infers control parameters.</p></td>
</tr>
<tr class="row-even"><td><p>minus_logp_red</p></td>
<td><p>Computes -log(p) of a partially observed trajectory</p></td>
</tr>
<tr class="row-odd"><td><p>compute_hessian_latent</p></td>
<td><p>Computes the Hessian of -log(p).</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Helper function</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>integrate</p></td>
<td><p>A wrapper around ‘simulate’ in pyross.deterministic.</p></td>
</tr>
<tr class="row-odd"><td><p>set_params</p></td>
<td><p>Sets parameters.</p></td>
</tr>
<tr class="row-even"><td><p>set_det_method</p></td>
<td><p>Sets the integration method of the deterministic equation</p></td>
</tr>
<tr class="row-odd"><td><p>set_lyapunov_method</p></td>
<td><p>Sets the integration method of the Lyapunov equation</p></td>
</tr>
<tr class="row-even"><td><p>make_det_model</p></td>
<td><p>Makes a pyross.deterministic model of the same class</p></td>
</tr>
<tr class="row-odd"><td><p>fill_params_dict</p></td>
<td><p>Fills and returns a parameter dictionary</p></td>
</tr>
<tr class="row-even"><td><p>fill_initial_conditions</p></td>
<td><p>Generates full initial condition with partial info.</p></td>
</tr>
</tbody>
</table>
<p>The functions are documented under the parent class <cite>SIR_type</cite>.</p>
<div class="section" id="sir-type">
<h2>SIR_type<a class="headerlink" href="#sir-type" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyross.inference.SIR_type">
<em class="property">class </em><code class="sig-prename descclassname">pyross.inference.</code><code class="sig-name descname">SIR_type</code><a class="headerlink" href="#pyross.inference.SIR_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Parent class for inference for all SIR-type classes listed below</p>
<p>All subclasses use the same functions to perform inference, which are documented below.</p>
<dl class="py method">
<dt id="pyross.inference.SIR_type.FIM">
<code class="sig-name descname">FIM</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.FIM" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Fisher Information Matrix (FIM) of the stochastic model.
:param param_keys: A list of parameters to be inferred.
:type param_keys: list
:param init_fltr: True for initial conditions to be inferred.</p>
<blockquote>
<div><p>Shape = (nClass*M)
Total number of True = total no. of variables - total no. of observed</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maps</strong> (<em>numpy.array</em>) – MAP parameter and initial condition estimate (computed for example with SIR_type.latent_inference).</p></li>
<li><p><strong>obs0</strong> (<em>numpy.array</em>) – The observed initial data</p></li>
<li><p><strong>fltr</strong> (<em>boolean sequence</em><em> or </em><em>array</em>) – True for observed and False for unobserved.
e.g. if only <cite>Is</cite> is known for SIR with one age group, fltr = [False, False, True]</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – Total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>float</em>) – Number of data points along the trajectory</p></li>
<li><p><strong>contactMatrix</strong> (<em>callable</em>) – A function that takes time (t) as an argument and returns the contactMatrix</p></li>
<li><p><strong>dx</strong> (<em>float</em><em>, </em><em>optional</em>) – Step size for numerical differentiation of the process mean and its full covariance matrix with respect
to the parameters. If not specified, the square root of the machine epsilon for the smallest entry on the
diagonal of the covariance matrix is chosen. Decreasing the step size too small can result in round-off error.</p></li>
<li><p><strong>tangent</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to use tangent space inference. Default is false.</p></li>
<li><p><strong>infer_scale_parameter</strong> (<em>bool</em><em> or </em><em>list of bools</em><em> (</em><em>size: number of age-dependenly specified parameters</em><em>)</em>) – Decide if age-dependent parameters are supposed to be inferred separately (default) or if a scale parameter
for the guess should be inferred. This can be set either globally for all age-dependent parameters or for each
age-dependent parameter individually</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>FIM</strong> – The Fisher Information Matrix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2d numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.FIM_det">
<code class="sig-name descname">FIM_det</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.FIM_det" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Fisher Information Matrix (FIM) of the deterministic model.
:param param_keys: A list of parameters to be inferred.
:type param_keys: list
:param init_fltr: True for initial conditions to be inferred.</p>
<blockquote>
<div><p>Shape = (nClass*M)
Total number of True = total no. of variables - total no. of observed</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maps</strong> (<em>numpy.array</em>) – MAP parameter and initial condition estimate (computed for example with SIR_type.latent_inference).</p></li>
<li><p><strong>obs0</strong> (<em>numpy.array</em>) – The observed initial data</p></li>
<li><p><strong>fltr</strong> (<em>boolean sequence</em><em> or </em><em>array</em>) – True for observed and False for unobserved.
e.g. if only <cite>Is</cite> is known for SIR with one age group, fltr = [False, False, True]</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – Total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>float</em>) – Number of data points along the trajectory</p></li>
<li><p><strong>contactMatrix</strong> (<em>callable</em>) – A function that takes time (t) as an argument and returns the contactMatrix</p></li>
<li><p><strong>measurement_error</strong> (<em>float</em><em>, </em><em>optional</em>) – Standard deviation of measurements (uniform and independent Gaussian measurement error assumed). Default is 1e-2.</p></li>
<li><p><strong>dx</strong> (<em>float</em><em>, </em><em>optional</em>) – Step size for numerical differentiation of the process mean and its full covariance matrix with respect
to the parameters. If not specified, the square root of the machine epsilon for the smallest entry on the
diagonal of the covariance matrix is chosen. Decreasing the step size too small can result in round-off error.</p></li>
<li><p><strong>infer_scale_parameter</strong> (<em>bool</em><em> or </em><em>list of bools</em><em> (</em><em>size: number of age-dependenly specified parameters</em><em>)</em>) – Decide if age-dependent parameters are supposed to be inferred separately (default) or if a scale parameter
for the guess should be inferred. This can be set either globally for all age-dependent parameters or for each
age-dependent parameter individually</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>FIM_det</strong> – The Fisher Information Matrix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2d numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.compute_hessian">
<code class="sig-name descname">compute_hessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Hessian of the MAP estimate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>keys</strong> (<em>list</em>) – A list of parameter names that are inferred</p></li>
<li><p><strong>maps</strong> (<em>numpy.array</em>) – MAP estimates</p></li>
<li><p><strong>prior_mean</strong> (<em>numpy.array</em>) – The mean of the prior (should be the same as “guess” for infer_parameters)</p></li>
<li><p><strong>prior_stds</strong> (<em>numpy.array</em>) – The standard deviations of the prior (same as “stds” for infer_parameters)</p></li>
<li><p><strong>x</strong> (<em>2d numpy.array</em>) – Observed trajectory (number of data points x (age groups * model classes))</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – Total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>float</em>) – Number of data points along the trajectory</p></li>
<li><p><strong>contactMatrix</strong> (<em>callable</em>) – A function that takes time (t) as an argument and returns the contactMatrix</p></li>
<li><p><strong>eps</strong> (<em>float</em><em> or </em><em>numpy.array</em><em>, </em><em>optional</em>) – The step size of the Hessian calculation, default=1e-3</p></li>
<li><p><strong>fd_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The type of finite-difference scheme used to compute the hessian, supports “forward” and “central”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>hess</strong> – The Hessian</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2d numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.compute_hessian_latent">
<code class="sig-name descname">compute_hessian_latent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.compute_hessian_latent" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Hessian over the parameters and initial conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maps</strong> (<em>numpy.array</em>) – MAP parameter and initial condition estimate (computed for example with SIR_type.latent_inference).</p></li>
<li><p><strong>obs</strong> (<em>numpy.array</em>) – The observed data with the initial datapoint</p></li>
<li><p><strong>fltr</strong> (<em>boolean sequence</em><em> or </em><em>array</em>) – True for observed and False for unobserved.
e.g. if only <cite>Is</cite> is known for SIR with one age group, fltr = [False, False, True]</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – Total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>int</em>) – Total number of data points along the trajectory</p></li>
<li><p><strong>contactMatrix</strong> (<em>callable</em>) – A function that returns the contact matrix at time t (input).</p></li>
<li><p><strong>eps</strong> (<em>float</em><em> or </em><em>numpy.array</em><em>, </em><em>optional</em>) – Step size in the calculation of the Hessian.</p></li>
<li><p><strong>obs0</strong> (<em>numpy.array</em><em>, </em><em>optional</em>) – Observed initial condition, if more detailed than obs[0]</p></li>
<li><p><strong>fltr0</strong> (<em>2d numpy.array</em><em>, </em><em>optional</em>) – Matrix filter for obs0</p></li>
<li><p><strong>fd_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The type of finite-difference scheme used to compute the hessian, supports “forward” and “central”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>hess</strong> – The Hessian over (flat) parameters and initial conditions.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.fill_initial_conditions">
<code class="sig-name descname">fill_initial_conditions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.fill_initial_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the full initial condition given partial initial conditions and the observed data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>partial_inits</strong> (<em>1d np.array</em>) – Partial initial conditions.</p></li>
<li><p><strong>obs_inits</strong> (<em>1d np.array</em>) – The observed initial conditions.</p></li>
<li><p><strong>init_fltr</strong> (<em>1d np.array</em>) – A vector boolean fltr that yields the partial initis given full initial conditions.</p></li>
<li><p><strong>fltr</strong> (<em>2d np.array</em>) – A matrix fltr that yields the observed data from full data. Same as the one used for latent_infer_parameters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x0</strong> – The full initial condition.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1d np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.fill_params_dict">
<code class="sig-name descname">fill_params_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.fill_params_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a full dictionary for epidemiological parameters with some changed values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>keys</strong> (<em>list of String</em>) – A list of names of parameters to be changed.</p></li>
<li><p><strong>params</strong> (<em>numpy.array of list</em>) – An array of the same size as keys for the updated value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>full_parameters</strong> – A dictionary of epidemiological parameters.
For parameter names specified in <cite>keys</cite>, set the values to be the ones in <cite>params</cite>;
for the others, use the values stored in the class.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.infer_control">
<code class="sig-name descname">infer_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.infer_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the maximum a-posteriori (MAP) estimate of the change of control parameters for a SIR type model in
lockdown. The lockdown is modelled by scaling the contact matrices for contact at work, school, and other
(but not home) uniformly in all age groups. This function infers the scaling parameters assuming that full data
on all classes is available (with latent variables, use SIR_type.latent_infer_control).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>guess</strong> (<em>numpy.array</em>) – Prior expectation (and initial guess) for the control parameter values</p></li>
<li><p><strong>stds</strong> (<em>numpy.array</em>) – Standard deviations for the log normal prior of the control parameters</p></li>
<li><p><strong>x</strong> (<em>2d numpy.array</em>) – Observed trajectory (number of data points x (age groups * model classes))</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – Total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>float</em>) – Number of data points along the trajectory</p></li>
<li><p><strong>generator</strong> (<em>pyross.contactMatrix</em>) – A pyross.contactMatrix object that generates a contact matrix function with specified lockdown
parameters.</p></li>
<li><p><strong>bounds</strong> (<em>2d numpy.array</em>) – Bounds for the parameters (number of parameters x 2).
Note that the upper bound must be smaller than the absolute physical upper bound minus epsilon</p></li>
<li><p><strong>intervention_fun</strong> (<em>callable</em><em>, </em><em>optional</em>) – The calling signature is <cite>intervention_func(t, **kwargs)</cite>, where t is time and kwargs are other keyword arguments for the function.
The function must return (aW, aS, aO). If not set, assume intervention that’s constant in time and infer (aW, aS, aO).</p></li>
<li><p><strong>tangent</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to use tangent space inference. Default is false.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to see intermediate outputs from the optimizer.</p></li>
<li><p><strong>ftol</strong> (<em>double</em>) – Relative tolerance of logp</p></li>
<li><p><strong>eps</strong> (<em>double</em>) – Disallow paramters closer than <cite>eps</cite> to the boundary (to avoid numerical instabilities).</p></li>
<li><p><strong>global_max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of global optimisations performed.</p></li>
<li><p><strong>local_max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of local optimisation performed.</p></li>
<li><p><strong>global_atol</strong> (<em>float</em>) – The absolute tolerance for global optimisation.</p></li>
<li><p><strong>enable_global</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to enable global optimisation.</p></li>
<li><p><strong>enable_local</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to enable local optimisation.</p></li>
<li><p><strong>cma_processes</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of parallel processes used for global optimisation.</p></li>
<li><p><strong>cma_population</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of samples used in each step of the CMA algorithm.</p></li>
<li><p><strong>cma_stds</strong> (<em>int</em><em>, </em><em>optional</em>) – The standard deviation used in cma global optimisation. If not specified, <cite>cma_stds</cite> is set to <cite>stds</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>res</strong> – MAP estimate of the control parameters</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.infer_parameters">
<code class="sig-name descname">infer_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.infer_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the maximum a-posteriori (MAP) estimate of the parameters of the SIR type model.
This function assumes that full data on all classes is available (with latent variables, use SIR_type.latent_inference).</p>
<p>IN DEVELOPMENT: Parameters that support age-dependent values can be inferred age-dependently by setting the guess
to a numpy.array of self.M initial values. By default, each age-dependent parameter is inferred independently.
If the relation of the different parameters is known, a scale factor of the initial guess can be inferred instead
by setting infer_scale_parameter to True for each age-dependent parameter where this is wanted. Note that
computing hessians for age-dependent rates is not yet supported. This functionality might be changed in the
future without warning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>keys</strong> (<em>list</em>) – A list of names for parameters to be inferred</p></li>
<li><p><strong>guess</strong> (<em>numpy.array</em><em> or </em><em>list</em>) – Prior expectation (and initial guess) for the parameter values. Age-dependent
rates can be inferred by supplying a guess that is an array instead a single float.</p></li>
<li><p><strong>stds</strong> (<em>numpy.array</em>) – Standard deviations for the log normal prior of the parameters</p></li>
<li><p><strong>bounds</strong> (<em>2d numpy.array</em>) – Bounds for the parameters (number of parameters x 2)</p></li>
<li><p><strong>x</strong> (<em>2d numpy.array</em>) – Observed trajectory (number of data points x (age groups * model classes))</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – Total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>float</em>) – Number of data points along the trajectory</p></li>
<li><p><strong>contactMatrix</strong> (<em>callable</em>) – A function that returns the contact matrix at time t (input).</p></li>
<li><p><strong>tangent</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to do inference in tangent space (might be less robust but a lot faster). Default is False.</p></li>
<li><p><strong>infer_scale_parameter</strong> (<em>bool</em><em> or </em><em>list of bools</em><em> (</em><em>size: number of age-dependenly specified parameters</em><em>)</em>) – Decide if age-dependent parameters are supposed to be inferred separately (default) or if a scale parameter
for the guess should be inferred. This can be set either globally for all age-dependent parameters or for each
age-dependent parameter individually</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to see intermediate outputs from the optimizer.</p></li>
<li><p><strong>ftol</strong> (<em>float</em>) – Relative tolerance of logp</p></li>
<li><p><strong>eps</strong> (<em>float</em>) – Disallow parameters closer than <cite>eps</cite> to the boundary (to avoid numerical instabilities).</p></li>
<li><p><strong>global_max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of global optimisations performed.</p></li>
<li><p><strong>local_max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of local optimisation performed.</p></li>
<li><p><strong>global_atol</strong> (<em>float</em>) – The absolute tolerance for global optimisation.</p></li>
<li><p><strong>enable_global</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to enable global optimisation.</p></li>
<li><p><strong>enable_local</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to enable local optimisation.</p></li>
<li><p><strong>cma_processes</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of parallel processes used for global optimisation.</p></li>
<li><p><strong>cma_population</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of samples used in each step of the CMA algorithm.</p></li>
<li><p><strong>cma_stds</strong> (<em>int</em><em>, </em><em>optional</em>) – The standard deviation used in cma global optimisation. If not specified, <cite>cma_stds</cite> is set to <cite>stds</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>estimates</strong> – The MAP parameter estimate</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>An light weight integrate method similar to <cite>simulate</cite> in pyross.deterministic</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>np.array</em>) – Initial state of the given model</p></li>
<li><p><strong>t1</strong> (<em>float</em>) – Initial time of integrator</p></li>
<li><p><strong>t2</strong> (<em>float</em>) – Final time of integrator</p></li>
<li><p><strong>steps</strong> (<em>int</em>) – Number of time steps for numerical integrator evaluation.</p></li>
<li><p><strong>model</strong> (<em>pyross model</em>) – Model to integrate (pyross.deterministic.SIR etc)</p></li>
<li><p><strong>contactMatrix</strong> (<em>python function</em><em>(</em><em>t</em><em>)</em>) – The social contact matrix C_{ij} denotes the
average number of contacts made per day by an
individual in class i with an individual in class j</p></li>
<li><p><strong>maxNumSteps</strong> – The maximum number of steps taken by the integrator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sol</strong> – The state of the system evaulated at the time point specified. Only used if det_method is set to ‘solve_ivp’.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.latent_infer_control">
<code class="sig-name descname">latent_infer_control</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.latent_infer_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the maximum a-posteriori (MAP) estimate of the change of control parameters for a SIR type model in
lockdown with partially observed classes. The unobserved classes are treated as latent variables. The lockdown
is modelled by scaling the contact matrices for contact at work, school, and other (but not home) uniformly in
all age groups. This function infers the scaling parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>keys</strong> (<em>list</em>) – A list of keys for the control parameters to be inferred.</p></li>
<li><p><strong>guess</strong> (<em>numpy.array</em>) – Prior expectation (and initial guess) for the control parameter values.</p></li>
<li><p><strong>stds</strong> (<em>numpy.array</em>) – Standard deviations for the log normal prior of the control parameters</p></li>
<li><p><strong>x0</strong> (<em>numpy.array</em>) – Initial conditions.</p></li>
<li><p><strong>obs</strong> – Observed trajectory (number of data points x (age groups * observed model classes)).</p></li>
<li><p><strong>fltr</strong> (<em>boolean sequence</em><em> or </em><em>array</em>) – True for observed and False for unobserved classes.
e.g. if only Is is known for SIR with one age group, fltr = [False, False, True]</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – Total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>float</em>) – Number of data points along the trajectory</p></li>
<li><p><strong>generator</strong> (<em>pyross.contactMatrix</em>) – A pyross.contactMatrix object that generates a contact matrix function with specified lockdown
parameters.</p></li>
<li><p><strong>bounds</strong> (<em>2d numpy.array</em>) – Bounds for the parameters (number of parameters x 2).
Note that the upper bound must be smaller than the absolute physical upper bound minus epsilon</p></li>
<li><p><strong>intervention_fun</strong> (<em>callable</em><em>, </em><em>optional</em>) – The calling signature is <cite>intervention_func(t, **kwargs)</cite>, where t is time and kwargs are other keyword arguments for the function.
The function must return (aW, aS, aO). If not set, assume intervention that’s constant in time and infer (aW, aS, aO).</p></li>
<li><p><strong>tangent</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to use tangent space inference. Default is false.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to see intermediate outputs from the optimizer.</p></li>
<li><p><strong>ftol</strong> (<em>double</em>) – Relative tolerance of logp</p></li>
<li><p><strong>global_max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of global optimisations performed.</p></li>
<li><p><strong>local_max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of local optimisation performed.</p></li>
<li><p><strong>global_atol</strong> (<em>float</em>) – The absolute tolerance for global minimisation.</p></li>
<li><p><strong>enable_global</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to enable global optimisation.</p></li>
<li><p><strong>enable_local</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to enable local optimisation.</p></li>
<li><p><strong>cma_processes</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of parallel processes used for global optimisation.</p></li>
<li><p><strong>cma_population</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of samples used in each step of the CMA algorithm.</p></li>
<li><p><strong>cma_stds</strong> (<em>int</em><em>, </em><em>optional</em>) – The standard deviation used in cma global optimisation. If not specified, <cite>cma_stds</cite> is set to <cite>stds</cite>.</p></li>
<li><p><strong>full_output</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to return full minimization output</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>params</strong> (<em>numpy.array</em>) – MAP estimate of control parameters</p></li>
<li><p><strong>y_result</strong> (<em>float (returned if full_output is True)</em>) – logp for MAP estimates</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.latent_infer_parameters">
<code class="sig-name descname">latent_infer_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.latent_infer_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the maximum a-posteriori (MAP) estimate of the parameters and the initial conditions of a SIR type model
when the classes are only partially observed. Unobserved classes are treated as latent variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param_keys</strong> (<em>list</em>) – A list of parameters to be inferred.</p></li>
<li><p><strong>init_fltr</strong> (<em>boolean array</em>) – True for initial conditions to be inferred.
Shape = (nClass*M)
Total number of True = total no. of variables - total no. of observed</p></li>
<li><p><strong>guess</strong> (<em>numpy.array</em><em> or </em><em>list</em>) – Prior expectation for the parameter values listed, and prior for initial conditions.
Expect of length len(param_keys)+ (total no. of variables - total no. of observed).
Age-dependent rates can be inferred by supplying a guess that is an array instead a single float.</p></li>
<li><p><strong>stds</strong> (<em>numpy.array</em>) – Standard deviations for the log normal prior.</p></li>
<li><p><strong>obs</strong> (<em>2d numpy.array</em>) – The observed trajectories with reduced number of variables
(number of data points, (age groups * observed model classes))</p></li>
<li><p><strong>fltr</strong> (<em>2d numpy.array</em>) – A matrix of shape (no. observed variables, no. total variables),
such that obs_{ti} = fltr_{ij} * X_{tj}</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – Total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>int</em>) – Total number of data points along the trajectory</p></li>
<li><p><strong>contactMatrix</strong> (<em>callable</em>) – A function that returns the contact matrix at time t (input).</p></li>
<li><p><strong>bounds</strong> (<em>2d numpy.array</em>) – Bounds for the parameters + initial conditions
((number of parameters + number of initial conditions) x 2).
Better bounds makes it easier to find the true global minimum.</p></li>
<li><p><strong>tangent</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to do inference in tangent space (might be less robust but a lot faster). Default is False.</p></li>
<li><p><strong>infer_scale_parameter</strong> (<em>bool</em><em> or </em><em>list of bools</em><em> (</em><em>size: number of age-dependenly specified parameters</em><em>)</em>) – Decide if age-dependent parameters are supposed to be inferred separately (default) or if a scale parameter
for the guess should be inferred. This can be set either globally for all age-dependent parameters or for each
age-dependent parameter individually</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to see intermediate outputs from the optimizer.</p></li>
<li><p><strong>ftol</strong> (<em>float</em><em>, </em><em>optional</em>) – Relative tolerance</p></li>
<li><p><strong>global_max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of global optimisations performed.</p></li>
<li><p><strong>local_max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of local optimisation performed.</p></li>
<li><p><strong>global_atol</strong> (<em>float</em>) – The absolute tolerance for global optimisation.</p></li>
<li><p><strong>enable_global</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to enable global optimisation.</p></li>
<li><p><strong>enable_local</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to enable local optimisation.</p></li>
<li><p><strong>cma_processes</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of parallel processes used for global optimisation.</p></li>
<li><p><strong>cma_population</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of samples used in each step of the CMA algorithm.</p></li>
<li><p><strong>cma_stds</strong> (<em>int</em><em>, </em><em>optional</em>) – The standard deviation used in cma global optimisation. If not specified, <cite>cma_stds</cite> is set to <cite>stds</cite>.</p></li>
<li><p><strong>obs0</strong> (<em>numpy.array</em><em>, </em><em>optional</em>) – Observed initial condition, if more detailed than obs[0]</p></li>
<li><p><strong>fltr0</strong> (<em>2d numpy.array</em><em>, </em><em>optional</em>) – Matrix filter for obs0</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>params</strong> – MAP estimate of paramters (nested if some parameters are age dependent) and initial values of the classes.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nested list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.log_G_evidence">
<code class="sig-name descname">log_G_evidence</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.log_G_evidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the evidence using a Laplace approximation at the MAP estimate.</p>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.log_G_evidence_latent">
<code class="sig-name descname">log_G_evidence_latent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.log_G_evidence_latent" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the evidence using a Laplace approximation at the MAP estimate.</p>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.make_det_model">
<code class="sig-name descname">make_det_model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.make_det_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a determinisitic model of the same epidemiological class and same parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>parameters</strong> (<em>dict</em>) – A dictionary of parameter values, same as the ones required for initialisation.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>det_model</strong> – A determinisitic model of the same epidemiological class and same parameters</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a class in pyross.deterministic</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.minus_logp_red">
<code class="sig-name descname">minus_logp_red</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.minus_logp_red" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes -logp for a latent trajectory</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parameters</strong> (<em>dict</em>) – A dictionary of parameter values, same as the ones required for initialisation.</p></li>
<li><p><strong>x0</strong> (<em>numpy.array</em>) – Initial conditions</p></li>
<li><p><strong>obs</strong> (<em>numpy.array</em>) – The observed trajectory without the initial datapoint</p></li>
<li><p><strong>fltr</strong> (<em>boolean sequence</em><em> or </em><em>array</em>) – True for observed and False for unobserved.
e.g. if only Is is known for SIR with one age group, fltr = [False, False, True]</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – The total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>int</em>) – The total number of datapoints</p></li>
<li><p><strong>contactMatrix</strong> (<em>callable</em>) – A function that returns the contact matrix at time t (input).</p></li>
<li><p><strong>tangent</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to do inference in tangent space (might be less robust but a lot faster). Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>minus_logp</strong> – -log(p) for the observed trajectory with the given parameters and initial conditions</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.nested_sampling_inference">
<code class="sig-name descname">nested_sampling_inference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.nested_sampling_inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log-evidence and weighted samples of the a-posteriori distribution of the parameters of a SIR type model
using nested sampling as implemented in the <cite>nestle</cite> Python package. This function assumes that full data on
all classes is available.</p>
<p>This function provides a computational alterantive to <cite>log_G_evidence</cite> and <cite>infer_parameters</cite>. It does not use
the Laplace approximation to compute the evidence and, in addition,  returns a set of representative samples that can
be used to compute a posterior mean estimate (insted of the MAP estimate). This approach approach is much more resource
intensive and typically only viable for small models or tangent space inference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>keys</strong> (<em>list</em>) – A list of names for parameters to be inferred</p></li>
<li><p><strong>guess</strong> (<em>numpy.array</em><em> or </em><em>list</em>) – Prior expectation (and initial guess) for the parameter values. Age-dependent
rates can be inferred by supplying a guess that is an array instead a single float.</p></li>
<li><p><strong>stds</strong> (<em>numpy.array</em>) – Standard deviations for the log normal prior of the parameters</p></li>
<li><p><strong>x</strong> (<em>2d numpy.array</em>) – Observed trajectory (number of data points x (age groups * model classes))</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – Total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>float</em>) – Number of data points along the trajectory</p></li>
<li><p><strong>contactMatrix</strong> (<em>callable</em>) – A function that returns the contact matrix at time t (input).</p></li>
<li><p><strong>bounds</strong> (<em>np.array</em><em>(</em><em>len</em><em>(</em><em>guess</em><em>)</em><em>, </em><em>2</em><em>)</em><em>, </em><em>optional</em>) – Bound the prior within the values specified by this. This can be used to avoid sampling the posterior
in regions where the solution is numerically unstable (e.g. parameters close to 0). Any bound introduces
a bias to the result, therefore one must make sure that the blocked regions are negligible.</p></li>
<li><p><strong>tangent</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to do inference in tangent space (might be less robust but a lot faster). Default is False.</p></li>
<li><p><strong>infer_scale_parameter</strong> (<em>bool</em><em> or </em><em>list of bools</em><em> (</em><em>size: number of age-dependenly specified parameters</em><em>)</em>) – Decide if age-dependent parameters are supposed to be inferred separately (default) or if a scale parameter
for the guess should be inferred. This can be set either globally for all age-dependent parameters or for each
age-dependent parameter individually</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to see intermediate outputs from the nested sampling procedure.</p></li>
<li><p><strong>queue_size</strong> (<em>int</em>) – Size of the internal queue of samples of the nested sampling algorithm. The log-likelihood of these samples
is computed in parallel (if queue_size &gt; 1).</p></li>
<li><p><strong>max_workers</strong> (<em>int</em>) – The maximal number of processes used to compute samples.</p></li>
<li><p><strong>npoints</strong> (<em>int</em>) – Argument of <cite>nestle.sample</cite>. The number of active points used in the nested sampling algorithm. The higher the
number the more accurate and expensive is the evidence computation.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – Nested sampling method used int <cite>nestle.sample</cite>, see their documentation. Default is <cite>single</cite>, for multimodel posteriors,
use <cite>multi</cite>.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em>) – Maximum number of iterations of the nested sampling algorithm.</p></li>
<li><p><strong>dlogz</strong> (<em>float</em><em>, </em><em>optional</em>) – Stopping threshold for the estimated error of the log-evidence. This option is mutually exclusive with <cite>decline_factor</cite>.</p></li>
<li><p><strong>decline_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – Stop the iteration when the weight (likelihood times prior volume) of newly saved samples has been declining for
<cite>decline_factor * nsamples</cite> consecutive samples. This option is mutually exclusive with <cite>dlogz</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>log_evidence</em> – The nested sampling estimate of the log-evidence.</p></li>
<li><p><em>(samples, weights)</em> – A set of weighted samples approximating the posterios distribution.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.nested_sampling_latent_inference">
<code class="sig-name descname">nested_sampling_latent_inference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.nested_sampling_latent_inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the log-evidence and weighted samples of the a-posteriori distribution of the parameters of a SIR type model
with latent variables using nested sampling as implemented in the <cite>nestle</cite> Python package.</p>
<p>This function provides a computational alterantive to <cite>latent_infer_parameters</cite>. It computes an estimate of the evidence and,
in addition, returns a set of representative samples that can be used to compute a posterior mean estimate (insted of the MAP
estimate). This approach approach is much more resource intensive and typically only viable for small models or tangent space inference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param_keys</strong> (<em>list</em>) – A list of parameters to be inferred.</p></li>
<li><p><strong>init_fltr</strong> (<em>boolean array</em>) – True for initial conditions to be inferred.
Shape = (nClass*M)
Total number of True = total no. of variables - total no. of observed</p></li>
<li><p><strong>guess</strong> (<em>numpy.array</em><em> or </em><em>list</em>) – Prior expectation for the parameter values listed, and prior for initial conditions.
Expect of length len(param_keys)+ (total no. of variables - total no. of observed).
Age-dependent rates can be inferred by supplying a guess that is an array instead a single float.</p></li>
<li><p><strong>stds</strong> (<em>numpy.array</em>) – Standard deviations for the log normal prior.</p></li>
<li><p><strong>obs</strong> (<em>2d numpy.array</em>) – The observed trajectories with reduced number of variables
(number of data points, (age groups * observed model classes))</p></li>
<li><p><strong>fltr</strong> (<em>2d numpy.array</em>) – A matrix of shape (no. observed variables, no. total variables),
such that obs_{ti} = fltr_{ij} * X_{tj}</p></li>
<li><p><strong>Tf</strong> (<em>float</em>) – Total time of the trajectory</p></li>
<li><p><strong>Nf</strong> (<em>int</em>) – Total number of data points along the trajectory</p></li>
<li><p><strong>contactMatrix</strong> (<em>callable</em>) – A function that returns the contact matrix at time t (input).</p></li>
<li><p><strong>bounds</strong> (<em>np.array</em><em>(</em><em>len</em><em>(</em><em>guess</em><em>)</em><em>, </em><em>2</em><em>)</em><em>, </em><em>optional</em>) – Bound the prior within the values specified by this array. This can be used to avoid sampling the posterior
in regions where the solution is numerically unstable (e.g. parameters close to 0). Any bound introduces
a bias to the result, therefore one must make sure that the blocked regions are negligible.</p></li>
<li><p><strong>obs0</strong> (<em>numpy.array</em><em>, </em><em>optional</em>) – Observed initial condition, if more detailed than obs[0]</p></li>
<li><p><strong>fltr0</strong> (<em>2d numpy.array</em><em>, </em><em>optional</em>) – Matrix filter for obs0</p></li>
<li><p><strong>tangent</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to do inference in tangent space (might be less robust but a lot faster). Default is False.</p></li>
<li><p><strong>infer_scale_parameter</strong> (<em>bool</em><em> or </em><em>list of bools</em><em> (</em><em>size: number of age-dependenly specified parameters</em><em>)</em>) – Decide if age-dependent parameters are supposed to be inferred separately (default) or if a scale parameter
for the guess should be inferred. This can be set either globally for all age-dependent parameters or for each
age-dependent parameter individually</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set to True to see intermediate outputs from the nested sampling procedure.</p></li>
<li><p><strong>queue_size</strong> (<em>int</em>) – Size of the internal queue of samples of the nested sampling algorithm. The log-likelihood of these samples
is computed in parallel (if queue_size &gt; 1).</p></li>
<li><p><strong>max_workers</strong> (<em>int</em>) – The maximal number of processes used to compute samples.</p></li>
<li><p><strong>npoints</strong> (<em>int</em>) – Argument of <cite>nestle.sample</cite>. The number of active points used in the nested sampling algorithm. The higher the
number the more accurate and expensive is the evidence computation.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – Nested sampling method used int <cite>nestle.sample</cite>, see their documentation. Default is <cite>single</cite>, for multimodel posteriors,
use <cite>multi</cite>.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em>) – Maximum number of iterations of the nested sampling algorithm.</p></li>
<li><p><strong>dlogz</strong> (<em>float</em><em>, </em><em>optional</em>) – Stopping threshold for the estimated error of the log-evidence. This option is mutually exclusive with <cite>decline_factor</cite>.</p></li>
<li><p><strong>decline_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – Stop the iteration when the weight (likelihood times prior volume) of newly saved samples has been declining for
<cite>decline_factor * nsamples</cite> consecutive samples. This option is mutually exclusive with <cite>dlogz</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>log_evidence</em> – The nested sampling estimate of the log-evidence.</p></li>
<li><p><em>(samples, weights)</em> – A set of weighted samples approximating the posterios distribution.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.set_det_method">
<code class="sig-name descname">set_det_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.set_det_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the method used for deterministic integration for the SIR_type model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>det_method</strong> (<em>str</em>) – The name of the integration method. Choose between ‘LSODA’, ‘RK45’, ‘RK2’ and ‘euler’.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.set_lyapunov_method">
<code class="sig-name descname">set_lyapunov_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.set_lyapunov_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the method used for deterministic integration for the SIR_type model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>det_method</strong> (<em>str</em>) – The name of the integration method. Choose between ‘LSODA’, ‘RK45’, ‘RK2’ and ‘euler’.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyross.inference.SIR_type.set_params">
<code class="sig-name descname">set_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyross.inference.SIR_type.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets epidemiological parameters used for evaluating -log(p)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>parameters</strong> (<em>dict</em>) – A dictionary containing all epidemiological parameters.
Same keys as the one used to initialise the class.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Can use <cite>fill_params_dict</cite> to generate the full dictionary if only a few parameters are changed</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="spp">
<h2>Spp<a class="headerlink" href="#spp" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyross.inference.Spp">
<em class="property">class </em><code class="sig-prename descclassname">pyross.inference.</code><code class="sig-name descname">Spp</code><a class="headerlink" href="#pyross.inference.Spp" title="Permalink to this definition">¶</a></dt>
<dd><p>User-defined epidemic model.</p>
<p>To initialise the Spp model,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model_spec</strong> (<em>dict</em>) – A dictionary specifying the model. See <cite>Examples</cite>.</p></li>
<li><p><strong>parameters</strong> (<em>dict</em>) – A dictionary containing the model parameters.
All parameters can be float if not age-dependent, and np.array(M,) if age-dependent</p></li>
<li><p><strong>M</strong> (<em>int</em>) – Number of age groups.</p></li>
<li><p><strong>fi</strong> (<em>np.array</em><em>(</em><em>M</em><em>) or </em><em>list</em>) – Fraction of each age group.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Total population.</p></li>
<li><p><strong>steps</strong> (<em>int</em>) – The number of internal integration steps performed between the observed points (not used in tangent space inference).
The minimal is 4, as required by the cubic spline fit used for interpolation.
For robustness, set steps to be large, det_method=’LSODA’, lyapunov_method=’LSODA’.
For speed, set steps to be 4, det_method=’RK2’, lyapunov_method=’euler’.
For a combination of the two, choose something in between.</p></li>
<li><p><strong>det_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The integration method used for deterministic integration.
Choose one of ‘LSODA’, ‘RK45’, ‘RK2’ and ‘euler’. Default is ‘LSODA’.</p></li>
<li><p><strong>lyapunov_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The integration method used for the integration of the Lyapunov equation for the covariance.
Choose one of ‘LSODA’, ‘RK45’, ‘RK2’ and ‘euler’. Default is ‘LSODA’.</p></li>
</ul>
</dd>
</dl>
<p>See <cite>SIR_type</cite> for a table of all the methods</p>
<p class="rubric">Examples</p>
<p>An example of model_spec and parameters for SIR class with a constant influx</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model_spec</span> <span class="o">=</span> <span class="p">{</span>
<span class="go">        &quot;classes&quot; : [&quot;S&quot;, &quot;I&quot;],</span>
<span class="go">        &quot;S&quot; : {</span>
<span class="go">            &quot;constant&quot;  : [ [&quot;k&quot;] ],</span>
<span class="go">            &quot;infection&quot; : [ [&quot;I&quot;, &quot;-beta&quot;] ]</span>
<span class="go">        },</span>
<span class="go">        &quot;I&quot; : {</span>
<span class="go">            &quot;linear&quot;    : [ [&quot;I&quot;, &quot;-gamma&quot;] ],</span>
<span class="go">            &quot;infection&quot; : [ [&quot;I&quot;, &quot;beta&quot;] ]</span>
<span class="go">        }</span>
<span class="go">    }</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
<span class="go">        &#39;beta&#39;: 0.1,</span>
<span class="go">        &#39;gamma&#39;: 0.1,</span>
<span class="go">        &#39;k&#39;: 1,</span>
<span class="go">    }</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sir">
<h2>SIR<a class="headerlink" href="#sir" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyross.inference.SIR">
<em class="property">class </em><code class="sig-prename descclassname">pyross.inference.</code><code class="sig-name descname">SIR</code><a class="headerlink" href="#pyross.inference.SIR" title="Permalink to this definition">¶</a></dt>
<dd><p>Susceptible, Infected, Removed (SIR)</p>
<ul class="simple">
<li><p>Ia: asymptomatic</p></li>
<li><p>Is: symptomatic</p></li>
</ul>
<p>To initialise the SIR class,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parameters</strong> (<em>dict</em>) – <p>Contains the following keys:</p>
<dl class="simple">
<dt>alpha: float</dt><dd><p>Ratio of asymptomatic carriers</p>
</dd>
<dt>beta: float</dt><dd><p>Infection rate upon contact</p>
</dd>
<dt>gIa: float</dt><dd><p>Recovery rate for asymptomatic</p>
</dd>
<dt>gIs: float</dt><dd><p>Recovery rate for symptomatic</p>
</dd>
<dt>fsa: float</dt><dd><p>The fraction of symptomatic people who are self-isolating</p>
</dd>
</dl>
</p></li>
<li><p><strong>M</strong> (<em>int</em>) – Number of age groups</p></li>
<li><p><strong>fi</strong> (<em>float numpy.array</em>) – Fraction of each age group</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Total population</p></li>
<li><p><strong>steps</strong> (<em>int</em>) – The number of internal integration steps performed between the observed points (not used in tangent space inference).
The minimal is 4, as required by the cubic spline fit used for interpolation.
For robustness, set steps to be large, det_method=’LSODA’, lyapunov_method=’LSODA’.
For speed, set steps to be 4, det_method=’RK2’, lyapunov_method=’euler’.
For a combination of the two, choose something in between.</p></li>
<li><p><strong>det_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The integration method used for deterministic integration.
Choose one of ‘LSODA’, ‘RK45’, ‘RK2’ and ‘euler’. Default is ‘LSODA’.</p></li>
<li><p><strong>lyapunov_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The integration method used for the integration of the Lyapunov equation for the covariance.
Choose one of ‘LSODA’, ‘RK45’, ‘RK2’ and ‘euler’. Default is ‘LSODA’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="seir">
<h2>SEIR<a class="headerlink" href="#seir" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyross.inference.SEIR">
<em class="property">class </em><code class="sig-prename descclassname">pyross.inference.</code><code class="sig-name descname">SEIR</code><a class="headerlink" href="#pyross.inference.SEIR" title="Permalink to this definition">¶</a></dt>
<dd><p>Susceptible, Exposed, Infected, Removed (SEIR)</p>
<ul class="simple">
<li><p>Ia: asymptomatic</p></li>
<li><p>Is: symptomatic</p></li>
</ul>
<p>To initialise the SEIR class,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parameters</strong> (<em>dict</em>) – <p>Contains the following keys:</p>
<dl class="simple">
<dt>alpha: float or np.array(M)</dt><dd><p>Fraction of infected who are asymptomatic.</p>
</dd>
<dt>beta: float</dt><dd><p>Rate of spread of infection.</p>
</dd>
<dt>gIa: float</dt><dd><p>Rate of removal from asymptomatic individuals.</p>
</dd>
<dt>gIs: float</dt><dd><p>Rate of removal from symptomatic individuals.</p>
</dd>
<dt>fsa: float</dt><dd><p>Fraction by which symptomatic individuals self isolate.</p>
</dd>
<dt>gE: float</dt><dd><p>rate of removal from exposed individuals.</p>
</dd>
</dl>
</p></li>
<li><p><strong>M</strong> (<em>int</em>) – Number of age groups</p></li>
<li><p><strong>fi</strong> (<em>float numpy.array</em>) – Fraction of each age group</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Total population</p></li>
<li><p><strong>steps</strong> (<em>int</em>) – The number of internal integration steps performed between the observed points (not used in tangent space inference).
The minimal is 4, as required by the cubic spline fit used for interpolation.
For robustness, set steps to be large, det_method=’LSODA’, lyapunov_method=’LSODA’.
For speed, set steps to be 4, det_method=’RK2’, lyapunov_method=’euler’.
For a combination of the two, choose something in between.</p></li>
<li><p><strong>det_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The integration method used for deterministic integration.
Choose one of ‘LSODA’, ‘RK45’, ‘RK2’ and ‘euler’. Default is ‘LSODA’.</p></li>
<li><p><strong>lyapunov_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The integration method used for the integration of the Lyapunov equation for the covariance.
Choose one of ‘LSODA’, ‘RK45’, ‘RK2’ and ‘euler’. Default is ‘LSODA’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="seairq">
<h2>SEAIRQ<a class="headerlink" href="#seairq" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="pyross.inference.SEAIRQ">
<em class="property">class </em><code class="sig-prename descclassname">pyross.inference.</code><code class="sig-name descname">SEAIRQ</code><a class="headerlink" href="#pyross.inference.SEAIRQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Susceptible, Exposed, Asymptomatic and infected, Infected, Removed, Quarantined (SEAIRQ)</p>
<ul class="simple">
<li><p>Ia: asymptomatic</p></li>
<li><p>Is: symptomatic</p></li>
<li><p>E: exposed</p></li>
<li><p>A: asymptomatic and infectious</p></li>
<li><p>Q: quarantined</p></li>
</ul>
<p>To initialise the SEAIRQ class,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parameters</strong> (<em>dict</em>) – <p>Contains the following keys:</p>
<dl class="simple">
<dt>alpha: float or np.array(M)</dt><dd><p>Fraction of infected who are asymptomatic.</p>
</dd>
<dt>beta: float</dt><dd><p>Rate of spread of infection.</p>
</dd>
<dt>gIa: float</dt><dd><p>Rate of removal from asymptomatic individuals.</p>
</dd>
<dt>gIs: float</dt><dd><p>Rate of removal from symptomatic individuals.</p>
</dd>
<dt>gE: float</dt><dd><p>rate of removal from exposed individuals.</p>
</dd>
<dt>gA: float</dt><dd><p>rate of removal from activated individuals.</p>
</dd>
<dt>fsa: float</dt><dd><p>fraction by which symptomatic individuals self isolate.</p>
</dd>
<dt>tE: float</dt><dd><p>testing rate and contact tracing of exposeds</p>
</dd>
<dt>tA: float</dt><dd><p>testing rate and contact tracing of activateds</p>
</dd>
<dt>tIa: float</dt><dd><p>testing rate and contact tracing of asymptomatics</p>
</dd>
<dt>tIs: float</dt><dd><p>testing rate and contact tracing of symptomatics</p>
</dd>
</dl>
</p></li>
<li><p><strong>M</strong> (<em>int</em>) – Number of age groups.</p></li>
<li><p><strong>fi</strong> (<em>float numpy.array</em>) – Fraction of each age group.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Total population.</p></li>
<li><p><strong>steps</strong> (<em>int</em>) – The number of internal integration steps performed between the observed points (not used in tangent space inference).
The minimal is 4, as required by the cubic spline fit used for interpolation.
For robustness, set steps to be large, det_method=’LSODA’, lyapunov_method=’LSODA’.
For speed, set steps to be 4, det_method=’RK2’, lyapunov_method=’euler’.
For a combination of the two, choose something in between.</p></li>
<li><p><strong>det_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The integration method used for deterministic integration.
Choose one of ‘LSODA’, ‘RK45’, ‘RK2’ and ‘euler’. Default is ‘LSODA’.</p></li>
<li><p><strong>lyapunov_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The integration method used for the integration of the Lyapunov equation for the covariance.
Choose one of ‘LSODA’, ‘RK45’, ‘RK2’ and ‘euler’. Default is ‘LSODA’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="control.html" class="btn btn-neutral float-right" title="Control with NPIs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="hybrid.html" class="btn btn-neutral float-left" title="Hybrid simulations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Ronojoy Adhikari, Austen Bolitho, Fernando Caballero, Michael Cates, Jakub Dolezal, Timothy Ekeh, Jules Guioth, Robert Jack, Julian Kappler, Lukas Kikuchi, Irene Li, Joseph Peterson, Patrick Pietzonka, Benjamin Remez, Paul Rohrbach, Rajesh Singh, and Günther Turk

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>